## 一  进程概念

> 进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe文件是个类，进程就是该类new出来的实例。 
> 进程是操作系统资源分配的最小单位（如虚拟内存资源），所有代码都是在进程中执行的。 

为了方便管理进程，每个进程都有自己的描述符，是个复杂的数据结构，我们称之为**进程控制块**，即PCB(Process Control Block)。  

PCB中保存了进程的管理、控制信息等数据，主要包含字段有：
- 进程ID（PID）：即ProcessID，是一个非负整数的顺序编号，用来对进程进行唯一标识
- 父进程ID（PPID）：当前进程的父进程ID
- 进程优先级
- 进程状态
- 虚拟地址范围
- 访问权限  

贴士：进程ID是可以重用的，当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个作为新进程的ID

## 二 进程创建

Unix系统在启动后，会首先运行一个名为 init 的进程，其PID 为 1。该进程是所有其他进程的父进程。  

Unix操作系统通过 `fork()` 函数能够创建多个子进程，从而能够提升计算机资源的利用率。此时调用者称为父进程，被创造出来的进程称为子进程。  
- 每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。  
- 子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。  

C语言中的进程创建如下：
```c
#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>
 
int main(){

    pid_t pid;

    pid = fork();                     // 创建子进程
    if (pid == -1){                   // 发生错误
        perror("fork发生错误 ");
        exit(1);
    }
 
    if(pid > 0){            // 返回值大于0时是父进程
        printf("父进程: pid = %d, ppid = %d \n", getpid(),getppid());
        sleep(1);           // 父进程睡眠，防止子进程还没运行完毕，父进程却直接退出了
    }
    
    if(pid == 0){           // 返回值为0的是子进程
        printf("子进程: pid = %d , ppid = %d \n", getpid(),getppid());
    }
    return 0; 
}
```

如上所示，创建的子进程可以直接开始运行，但是也可以通过 `exec()` 函数来加载一个全新的程序，此时子进程会丢弃现存的程序文本段，为加载的新程序重新创建栈、数据段、堆，我们对这一个过程称为执行一个新程序。  

使用C语言执行一个新程序：
```c
#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>
 
int main(){

    pid_t pid;
    int r;

    pid = fork();                     // 创建子进程
    if (pid == -1){                   // 发生错误
        perror("fork发生错误 ");
        exit(1);
    }
 
    if(pid > 0){            
        printf("父进程运行中...\n");
        sleep(3);     
    }
    
    if(pid == 0){          
        printf("子进程运行中...\n");
        // 子进程执行新程序：系统自带的 echo程序，输出 hello world!
        char * execv_str[] = {"echo", "hello world!",NULL};
        int r = execv("/bin/echo", execv_str);    // 笔者的是mac，linux上为： "/usr/bin/echo"  
		if (r <0 ){
			perror("error on exec");
			exit(0);
        }
    }
    return 0; 
}
```

贴士：exec并不是1个函数, 是一系列 exec 开头的函数，作用都是执行新程序。

## 三 Go创建进程

在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，具体信息可以参见Go的os包。

```go

```




父进程无法预测子进程什么时候结束，只有进程完成工作后，父进程才会调用子进程的终止态。  

多进程容易产生的问题：  
- 孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，且系统最开始的init进程称为其父进程，我们称之为init进程领养孤儿进程。  
- 僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。



贴士：全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。  

新建的子进程可以通过系统调用函数exec()把一个新的程序加载到自己的内存中，而原先在其内存中的数据段、堆、栈、代码段都会被替换为新程序对应的数据。

Unix系统每个进程都有父进程，所有进程组成了进程树状结构，内核启动基础进程是进程树的根，负责系统的初始化操作，它的父进程就是它自己。  

多进程容易产生的问题：  
- 孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，且系统最开始的init进程称为其父进程，我们称之为init进程领养孤儿进程。  
- 僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。  


#### 1.4 进程的状态

通常Linux的进程状态有6种：
- 可运行R（TASK_RUNNING）：进程正在CPU上运行或立刻准备运行，其运行的时机不确定，由进程调度器决定  
- 可中断睡眠S(TASK_INTERRUPTIBLE)：进程在等待某个事件到来（如网络连接、信号量），这样的进程会被放入对应事件的等待队列中，当事件发生时，会被唤醒
- 不可中断睡眠D(TASK_UNINTERRUOTIBLE)：该状态进程不会对任何信号做出响应，通常是在等待一个特殊的事件，比如I/O  
- 暂停/跟踪T(TASK_STOPPED/TASK_TRACED)：向进程发送SIGSTOP信号，就会使进程进入该状态，处于该状态的进程会暂停，并等待另一个进程（跟踪它的进程）对它进行操作，常见的案例有gdb断点调试进入断点时刻。  
- 僵尸Z(TASK_DEAD-EXIT_ZOMBIE)：进程即将结束运行，该进程占用的绝大多数资源也都已经被回收，不过还有一些信息未被删除，如退出码、统计信息等，因为父进程可能需要他们。  
- 退出X(TASK_DEAD-EXIT-DEAD)：进程即将结束时，可以不进入僵尸状态，直接进入退出状态，即不保留退出码、统计信息等，会被立即销毁。 

贴士：
- 在生命周期内：进程只会在可运行状态和非可运行状态之间转换。 
- 进程处于不可中断状态，发送SIGSTOP信号无效
- 进程处于暂停状态，发送SIGSTOP信号会使该进程转向可运行状态
- 造成进程直接退出的原因：
    - 当一个进程即将消亡的时，内核会向其父进程发送SIGCHLD信号告知情况，程序显式让父进程忽略掉了SIGCHLD信号
    - 也可能是该进程已经被分离（父子进程分别独立运行），分离后的子程序不会再使用和执行与父进程共享的代码段中的指令，而是加载并运行一个全新的程序。

进程的状态转换图：  
![](../images/go/02-03.svg)

#### 1.5 进程分类

进程分类：
- 用户进程：位于用户空间中，是程序执行的实例
- 内核进程：位于内核空间中，可以访问硬件

由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。  

内核为了保证系统的安全和稳定，为CPU特供了两个状态：内核态与用户态： 
- 用户态：大部分时间CPU处于该状态，此时只能访问用户空间
- 内核态：当用户进程发起系统调用（即操作刚才所说的接口），内核会将CPU切换到内核态，然后执行相应接口函数。

#### 1.6 进程的切换和调度-上下文切换

操作系统可以在在多个进程之间来回切换，产生多个进程同时运行的假象，每个进程都会认为自己独占了CPU，这就是多任务操作系统的由来。但是无论切换速度如何，同一时刻正在运行的进程仅会有一个。  

切换进程是有代价的，因为必须保存进程的运行时状态。  

进程的切换和调度是多程序并发执行的基础。

## 二 进程通信

#### 2.1 进程的通信方式

由于进程拥有互相独立的地址空间，所以进程之间无法直接通信，必须利用进程间通信(IPC,InterProcess Communication)方式来实现通信：
- 基于通信的IPC方法：
    - 以数据传送为手段：包括管道（pipe：负责传送字节流）、消息队列（message queue：负责传送结构化对象）
    - 以共享内存为手段：共享内存区(shared memeory)，是最快的IPC方法
- 基于信号的IPC方法：即操作系统的信号机制（signal），是异步的IPC方法
- 基于同步的IPC方法：基于信号量(semaphore)

Go支持的IPC方法有：管道、信号、socket。  

#### 2.2 同步

当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程A对其进行执行`一系列`操作，但是在执行过程中，系统有可能会切换到另外一个进程B中，B也对该数据进行`一系列`操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？    

原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go中(sync/atomic包提供了原子操作函数)。  

注意：
- 所有的系统调用都是原子操作，即不用担心它们的执行被中断！
- 原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。 

问题：如果一个原子操作无法结束，现在也无法中断，如何处理？  
> 答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。  

互斥锁：  
在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang的sync包也有对互斥的支持。  

#### 2.3 管道  

管道pipe用于父子进程、同祖先子进程之间通信。例如Linux的命令：`ps aux | grep go`，shell为每个命令创建一个进程，然后把左边命令的标准输出用管道与右边命令的标准输入连接起来。  

Go模拟`echo -n "hello pipe"`：
```go 
import(
	"fmt"
	"os/exec"
)

func main() {
	cmd0 := exec.Command("echo", "-n", "hello")
	stdout0, _ := cmd0.StdoutPipe()         // 将输出管道的值赋值给了 stdout0
	cmd0.Start()
	output0 := make([]byte, 30)
	n, _ := stdout0.Read(output0)
	fmt.Println(string(output0[:n]))
}
```

Go模拟`ps aux | grep apipe`：

```go
	cmd1 := exec.Command("ps", "aux")
	cmd2 := exec.Command("grep", "apipe")

	var outputBuf1 bytes.Buffer
	cmd1.Stdout = &outputBuf1
	cmd1.Start()
	cmd1.Wait()				// 开始阻塞

	var outputBuf2 bytes.Buffer
	cmd2.Stdout = &outputBuf2
	cmd2.Start()
	cmd2.Wait()				// 开始阻塞

	fmt.Println(outputBuf2.Bytes())
```

#### 2.4 信号

信号是IPC中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go中的ginal包提供了相关操作。  

```go
	sigRecv := make(chan os.Signal, 1)                      // 创建接收通道
	sigs := []os.Signal{syscall.SIGINT, syscall.SIGQUIT}    // 创建信号类型
	signal.Notify(sigRecv, sigs...)
	for sig := range sigRecv {                              // 循环接收通道中的信号，通道关闭后，for会立即停止
		fmt.Println(sig)
	} 
```

#### 2.5 socket

socket即套接字，也是一种IPC方法，与其他IPC方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。