## 一 线程

#### 1.1 线程概述

> 线程：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位（即cpu分配时间轮片的对象）

一个进程内部可以创建多个线程，他们与进程一样拥有独立的PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需IPC，直接就能通信！！（因为他们在同一个地址空间内）。  

共享地址空间：
![](../images/go/02-01.svg)

虽然线程带来了通信的便利，但是从图中也能发现，如果同一空间的中多个线程同时去修改同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题！  

线程可以视为某个进程内部的控制流，一个进程内部的线程包括：
- 主线程：必定拥有，因为进程必须有一个控制流持续运行，该线程随着进程的启动而创建
- 其他线程：不一定拥有，由主线程或者其他线程创建（调用pthread_create函数）  

注意：
- 线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期  
- 与进程不同，线程不存在父子级别关系，同一进程中的任意2个线程之间的关系是平等的

线程自己私有的数据都存储在线程栈中，线程栈位于所属进程的虚拟内存地址中。  

![](../images/go/02-01.svg)  


不过，一个进程的很多资源会被所有线程共享，比如：代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符等。所以，同一进程中的多个线程运行的一定是同一个程序，只不过具体的控制流和执行的函数可能不同。也正因如此，同一进程内的多线程共享数据变得很轻松，创建新线程也无需再复制资源了。

#### 1.2 线程标识

每个线程也有属于自己的ID，称为TID，只在其所属的进程范围内唯一。  

注意：Linux中的线程ID在系统范围内也是唯一的，且线程不存在后，该ID可被其他线程复用。  
  
#### 1.3 线程调度

线程之间不存在类似进程的树形关系，任何线程都可以对同一进程的其他线程进行有限的管理。

调度器会把事件划分为极小的时间片，并把这些时间片分配给不同的线程，以使众多线程都有机会在CPU上运行，也造成了我们多线程被并行运行的幻觉。

## 二 线程同步-互斥方式

#### 2.1 共享数据一致性

在多线程开发中，我们总是设法保证共享数据的一致性，除非该数据永远只被一个线程访问。

共享数据大多存放在共享内存中。保证共享数据一致性的最简单和最彻底的方法就是使该数据编程一个不变量，在编程语言中可以使用常量来确保。但是类似计数器这样的数据变成常量是不现实的，必须通过额外手段来保证被多个线程共享变量的一致性，这既是前面所提到的临界区。  

临界区是只能被串行化访问或执行的某个资源或某段代码，常称为串行区域。一般通过同步机制来保证临界区有效，常见的同步机制有：原子操作、互斥量、条件变量等。

#### 2.2 互斥量

互斥（mutex）：在同一时刻，只允许一个线程处于临界区内。  

互斥量：线程将对象锁定后，才能进入临界区，否则线程就会阻塞，这个对象我们称之为互斥对象或者互斥量。  

由此可知，互斥量有已锁定、未锁定两种状态，且一旦被锁，则不能再次锁定，只有解锁后才能再次锁定（即不允许别的线程二次加锁）。多个线程为了能够访问临界区，将会争夺锁的所有权。  

线程在离开临界区的时候，必须对互斥量进行解锁，此时其他想进入该临界区的线程将会被唤醒再次争夺锁。  

#### 2.3 死锁

如果不同的临界区中 包含了对同一个共享资源的同一种操作，此时会产生死锁。  

解决死锁的办法有两种：
- 试锁定-回退：操作系统的线程库中提供了该功能。在执行一个代码块时，如果需要先后锁定多个互斥量，成功锁定其中一个互斥量后应该使用试锁定的方法来锁定后续互斥量，如果后续任一互斥量锁定失败，则解锁刚才被锁的互斥量，重新进行争夺锁尝试。
  - 注意：多个互斥量被成功加锁后，解锁顺序和加锁顺序相反，这样可以减少回退次数。
- 固定顺序锁定：举例，线程A和线程B总是先锁定互斥量1，再锁定互斥量2，那么就不会产生死锁。

第一种方案更加有效，但是程序变得复杂了，后一种方法简单实用，但是因为存在固定顺序，降低了程序的灵活性。  

## 三 线程同步-条件变量方式

互斥量有时候也不能完美解决问题，比如： 
```
有一个数据队列，存在着生产者线程、消费者线程对该队列数据的使用，使用互斥量保护该数据队列，生产者线程添加数据，消费者线程消费数据。  

如果生产者线程获得互斥量，发现数据队列已满，无法添加新数据，这时生产者线程可能就会在临界区等待，直到有空闲区间，这种做法明显是错误的，应该在发现没有空闲区间时直接解锁退出。  

同样消费者线程获取锁后，发现数据队列为空，则也会一直等待，我们也推荐发现为空后直接解锁。
```

引入条件变量，与互斥量配合使用，可以解决上述问题。  

条件变量：条件变量一般与互斥量组合使用，在对应的共享数据状态发生变化时，通知其他被阻塞线程。    


条件变量有三种操作：
- 等待通知（wait）：如果当前数据状态不满足条件，则解锁与该条件变量绑定在一起的互斥量，然后阻塞当前线程，直到收到该条件变量发来的通知
- 单发通知（signal）：让条件变量向至少一个正在等待它通知的线程发送通知，以表示共享数据状态发生了改变 
- 广播通知（broadcast）：给等待通知的所有线程发送通知


#### 四 多进程与多线程利弊

交换数据：
- 多进程交换数据方式复杂（管道、消息队列、信号量、共享内存）
- 多线程之间交换数据很简单，但会产生竞态条件，需要解决同步问题

综合而言，多线程方式具备大量优势，但是在处理信号、同时运行多套不同程序以及包含多个需要超大内存支持的任务等，多进程方式更适合。  
