## 一  进程

#### 1.1 进程的定义 

一个程序的执行称为一个进程，即进程是用来描述程序的执行过程。进程是操作系统进行资源分配的基本单位，所有代码都是在进程中执行的。  

#### 1.2 进程的衍生

使用操作系统的调用函数fork可以创建若干个新的进程，调用者称为父进程，被创造出来的进程称为子进程。  
- 每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。  
- 子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。  

贴士：全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。  

新建的子进程可以通过系统调用函数exec()把一个新的程序加载到自己的内存中，而原先在其内存中的数据段、堆、栈、代码段都会被替换为新程序对应的数据。

Unix系统每个进程都有父进程，所有进程组成了进程树状结构，内核启动基础进程是进程树的根，负责系统的初始化操作，它的父进程就是它自己。  

多进程容易产生的问题：  
- 孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，且系统最开始的init进程称为其父进程，我们称之为init进程领养孤儿进程。  
- 僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。  

#### 1.3 进程的标识

为了方便管理进程，每个进程都有自己的描述符，描述符是个复杂的数据结构，包含每个进程的属性和行为，即：进程ID（PID）、父进程ID（PPID）、优先级、状态、虚拟地址范围、访问权限等。  

进程ID常识：
- PID：是进程在操作系统中的唯一标识，是一个非负整数且总是顺序的编号，新建进程时依次递增，其中值为1的进程是内核启动进程
- PPID：当前进程的父进程ID，通常可以据此找到守护进程踪迹 
- ID重用：当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个作为新进程的ID

Go中获取当前进程的ID和PPID：
```go
    pid := os.Getpid()
    ppid := os.Getppid()
``` 

#### 1.4 进程的状态

通常Linux的进程状态有6种：
- 可运行R（TASK_RUNNING）：进程正在CPU上运行或立刻准备运行，其运行的时机不确定，由进程调度器决定  
- 可中断睡眠S(TASK_INTERRUPTIBLE)：进程在等待某个事件到来（如网络连接、信号量），这样的进程会被放入对应事件的等待队列中，当事件发生时，会被唤醒
- 不可中断睡眠D(TASK_UNINTERRUOTIBLE)：该状态进程不会对任何信号做出响应，通常是在等待一个特殊的事件，比如I/O  
- 暂停/跟踪T(TASK_STOPPED/TASK_TRACED)：向进程发送SIGSTOP信号，就会使进程进入该状态，处于该状态的进程会暂停，并等待另一个进程（跟踪它的进程）对它进行操作，常见的案例有gdb断点调试进入断点时刻。  
- 僵尸Z(TASK_DEAD-EXIT_ZOMBIE)：进程即将结束运行，该进程占用的绝大多数资源也都已经被回收，不过还有一些信息未被删除，如退出码、统计信息等，因为父进程可能需要他们。  
- 退出X(TASK_DEAD-EXIT-DEAD)：进程即将结束时，可以不进入僵尸状态，直接进入退出状态，即不保留退出码、统计信息等，会被立即销毁。 

贴士：
- 在生命周期内：进程只会在可运行状态和非可运行状态之间转换。 
- 进程处于不可中断状态，发送SIGSTOP信号无效
- 进程处于暂停状态，发送SIGSTOP信号会使该进程转向可运行状态
- 造成进程直接退出的原因：
    - 当一个进程即将消亡的时，内核会向其父进程发送SIGCHLD信号告知情况，程序显式让父进程忽略掉了SIGCHLD信号
    - 也可能是该进程已经被分离（父子进程分别独立运行），分离后的子程序不会再使用和执行与父进程共享的代码段中的指令，而是加载并运行一个全新的程序。

进程的状态转换图：  
![](../images/go/02-03.svg)

#### 1.5 进程分类

进程分类：
- 用户进程：位于用户空间中，是程序执行的实例
- 内核进程：位于内核空间中，可以访问硬件

由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。  

内核为了保证系统的安全和稳定，为CPU特供了两个状态：内核态与用户态： 
- 用户态：大部分时间CPU处于该状态，此时只能访问用户空间
- 内核态：当用户进程发起系统调用（即操作刚才所说的接口），内核会将CPU切换到内核态，然后执行相应接口函数。

#### 1.6 进程的切换和调度-上下文切换

操作系统可以在在多个进程之间来回切换，产生多个进程同时运行的假象，每个进程都会认为自己独占了CPU，这就是多任务操作系统的由来。但是无论切换速度如何，同一时刻正在运行的进程仅会有一个。  

切换进程是有代价的，因为必须保存进程的运行时状态。  

进程的切换和调度是多程序并发执行的基础。

## 二 进程通信

#### 2.1 进程的通信方式

在多进程程序中，多个进程之间经常需要协作完成任务，这种通信方式称为IPC（Inter-Process Communication），在Linux中分类有：
- 基于通信的IPC方法：
    - 以数据传送为手段：包括管道（pipe：负责传送字节流）、消息队列（message queue：负责传送结构化对象）
    - 以共享内存为手段：共享内存区(shared memeory)，是最快的IPC方法
- 基于信号的IPC方法：即操作系统的信号机制（signal），是异步的IPC方法
- 基于同步的IPC方法：基于信号量(semaphore)

Go支持的IPC方法有：管道、信号、socket。  

#### 2.2 同步

当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程A对其进行执行`一系列`操作，但是在执行过程中，系统有可能会切换到另外一个进程B中，B也对该数据进行`一系列`操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？    

原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go中(sync/atomic包提供了原子操作函数)。  

注意：
- 所有的系统调用都是原子操作，即不用担心它们的执行被中断！
- 原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。 

问题：如果一个原子操作无法结束，现在也无法中断，如何处理？  
> 答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。  

互斥锁：  
在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang的sync包也有对互斥的支持。  

#### 2.3 管道  

管道pipe用于父子进程、同祖先子进程之间通信。例如Linux的命令：`ps aux | grep go`，shell为每个命令创建一个进程，然后把左边命令的标准输出用管道与右边命令的标准输入连接起来。  

Go模拟`echo -n "hello pipe"`：
```go 
import(
	"fmt"
	"os/exec"
)

func main() {
	cmd0 := exec.Command("echo", "-n", "hello")
	stdout0, _ := cmd0.StdoutPipe()         // 将输出管道的值赋值给了 stdout0
	cmd0.Start()
	output0 := make([]byte, 30)
	n, _ := stdout0.Read(output0)
	fmt.Println(string(output0[:n]))
}
```

Go模拟`ps aux | grep apipe`：

```go
	cmd1 := exec.Command("ps", "aux")
	cmd2 := exec.Command("grep", "apipe")

	var outputBuf1 bytes.Buffer
	cmd1.Stdout = &outputBuf1
	cmd1.Start()
	cmd1.Wait()				// 开始阻塞

	var outputBuf2 bytes.Buffer
	cmd2.Stdout = &outputBuf2
	cmd2.Start()
	cmd2.Wait()				// 开始阻塞

	fmt.Println(outputBuf2.Bytes())
```

#### 2.4 信号

信号是IPC中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go中的ginal包提供了相关操作。  

```go
	sigRecv := make(chan os.Signal, 1)                      // 创建接收通道
	sigs := []os.Signal{syscall.SIGINT, syscall.SIGQUIT}    // 创建信号类型
	signal.Notify(sigRecv, sigs...)
	for sig := range sigRecv {                              // 循环接收通道中的信号，通道关闭后，for会立即停止
		fmt.Println(sig)
	} 
```

#### 2.5 socket

socket即套接字，也是一种IPC方法，与其他IPC方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。