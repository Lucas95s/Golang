## 一 并发与并行
并行：任意粒度的时间内都具备同时执行的能力，最简单的并行就是多机，多台机器并行处理
并发：规定时间内多个请求都得到执行和处理，强调的是给外界的感觉，实际上内部可能是分时操作的。并发重在避免阻塞，使程序不会因为一个阻塞而停止。
并发解决方案：
> 1 多进程:在操作系统层面并发，由于由系统内核管理，操作简单、进程互不影				响，但是开销最大；
> 2 多线程:多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存				在死锁管理问题。
> 3 非阻塞IO:基于回调的异步非阻塞IO，尽可能少的运用线程，见Node.js
> 4协程:本质上是用户态线程，不需要系统进行抢占式调度，且真正的实现寄				存于线程中，开销极小。
协程：
协程的优势在于其轻量级，可以轻松创建上百万个协程而不会造成系统资源衰竭。
线程需要上下文不停切换，协程不会主动交出使用权，除非代码中主动要求切换，或者发生IO。（主动切换函数：runtime.Gosched）
这样如果没有主动切换、IO，那么协程一直运行下去，遇到IO，则立即切换到被的协程，很好的解决了并发编程。

Go直接从语言层面支持了并发，goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过`go`关键字实现了，其实就是一个普通的函数。
案例：
```Go
func say(s string) {
	for i := 0; i < 5; i++ {
		runtime.Gosched()
		fmt.Println(s)
	}
}

func main() {
	go say("world") //开一个新的Goroutines执行
	say("hello") //当前Goroutines执行
}

// 以上程序执行后将输出：
// hello
// world
// hello
// world
// hello
// world
// hello
// world
// hello

```
> runtime.Gosched()表示让CPU把时间片让给别人,下次某个时候继续恢复执行该goroutine。
> 默认情况下，在Go 1.5将标识并发系统线程个数的runtime.GOMAXPROCS的初始值由1改为了运行环境的CPU核数。
但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要在我们的程序中显式调用 runtime.GOMAXPROCS(n) 告诉调度器同时使用多个线程。GOMAXPROCS 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果n < 1，不会改变当前设置。  
Go协程的特点：
- 有独立的栈空间
- 共享程序堆空间
- 调度由用户控制
- 协程是轻量级的线程
注意：如果主线程退出了，则协程及时还没有执行完毕也退出
## 二 并发模型
#### 2.1 常见并发模型
在工程上，有两种常见并发模型：共享数据和消息。共享数据最常见的是共享内存。
多线程共享内存：
线程加共享内存的方式归纳为 共享内存系统。线程间共享状态的各种操作都被封装在线程之间的传递消息中。这就需要：发送消息时，对状态进行复制，并且在消息传递的边界上交出这个状态的所有权。由于复制的存在，造成了性能问题。
Go使用消息机制而非共享内存作为通信方式。消息机制认为每个并发单元是自包含的、独立的个体，都有自己的变量，在不同并发单元间不共享，不同单元间输入输出只有消息，类似于进程间互不打扰。Go的这个使用方式称为channel。
#### 2.2 goroutine调度模型
MPG模式运行状态1：
![](/images/Golang/并发-01.png)
- M:操作系统的主线程（是物理线程），P:协程执行时需要的上下文，G：协程
- 上图中，当前程序有三个物理线程，如果三个物理线程都在同一个CPU运行，就是并发，否则是并行。
- Go的协程是轻量的逻辑态的，Java的多线程是重量的内核态的，几千个线程可能会耗光CPOU
#### 2.3 设置Golang运行cpu数
在Go1.8之后，程序默认运行在多核上，无需设置，1.8之前需要如下设置：
```go
package main
import "runtime"
func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
}
```