## 一 并发编程历史

并发概念由来已久，其主要思想是使多个任务可以在同一个时间内执行以便更快的得到结果。  

在早期的操作系统中，任务是一个接着一个运行的，各个任务的执行完全是串行的，只有在一个任务运行完成之后，另一个任务才会被读取。  

并发编程的思想来自于多任务操作系统，它允许同时运行多个程序。当一个程序暂时不需要使用CPU的时候，系统会把该程序挂起或中断，以使其他程序可以使用CPU。  

对并发的支持从汇编语言开始就存在了，只不过这样会引起对系统资源的无限制抢夺，造成死锁。  

在20世纪70年代，第一本关于并发理论的书籍问世，经过学术界不断地探索，终于形成了完善的并发理论模型。

## 二 串行与并发

#### 2.1 并发理论基础

串行与并发区别：
- 串行程序：只能被顺序执行的指令列表；
- 并发程序：可以被并发执行的两个及两个以上的串行程序的综合体。  

并发程序能够得以执行，依赖于两个要素：
- 多元程序：并发程序内部的串行程序被允许运行在一个或者多个可共享的CPU上（1968年荷兰图领奖得住提出的多个串行程序复用多个CPU的方法）
- 多元处理：并发程序内部的串行程序也被允许运行在专为他服务的CPU上（1980年美国计算机学家提出的多个CPU使用同一个内存，且在同一时刻可能会有数个串行程序分别运行在不同的CPU上）

多元程序和多元处理经过长久的发展，已经得到了很好的融合，为并发理论提供了支持。

#### 2.2 并发与并行

并发与并行区别：
- 并发程序：可以被同时发起的执行程序，是个宽泛的概念
- 并行程序：可以在并行的硬件上执行的并发程序

程序与程序之间通过协商一致的协议进行通信，可以统一看做是一个系统，即并发系统。并发系统更有可能是并行的，因为其中的多个程序一般可以同时在不同的硬件环境上运行，因此并发系统也通常称为并行系统（当然有一个更流行的同义词：分布式系统）。 

#### 2.3 并发程序的内部交互

并发程序内部会被划分为多个部分，每个部分都可以看作为一个串行程序，不同的串行程序之间，可能存在交互的需求，比如常见的多个串行程序可能都要访问同一个资源，或者彼此间需要传递数据。此时我们就需要协调它们的执行，这就涉及了同步。  

同步的作用是避免在并发访问共享资源时可能发生的冲突。  

根据同步原则，程序如果想使用一个共享数据，就必须先请求该资源并获取到堆它的访问权，当程序不再需要某个资源的时，它应该放弃对该资源的访问权(即：释放资源)。一个程序对资源的请求不应该导致其他正在访问该资源的程序中断，而应该等到那个程序释放资源之后再进行请求。  

也就是说：在同一时刻，某个资源应该只被一个程序占用。  

传递数据是并发程序内部的另一种交互方式，也称为并发程序内部的通信。协调这种内部通信的方式不只同步一种，也可以使用异步方式对通信进行管理。这种方式可以使数据不加延迟的发送给数据接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。数据会被临时存储在一个称谓通信缓存的数据结构中。  

通信缓存是一种特殊的数据结构，可以同时被多个程序使用，数据接收方可以在准备就绪之后按照数据存入通信缓存的顺序接收它们。  

## 三  多进程编程

#### 3.1 进程的定义 

所有的代码都是在进程中执行的，进程是UNIX系操作系统的根本。我们常把一个程序的执行成为一个进程，即进程是用来描述程序的执行过程。  

进程是操作系统进行资源分配的基本单位。

#### 3.2 进程的衍生

使用操作系统的调用函数for可以创建若干个新的进程，调用者称为父进程，被创造出来的进程称为子进程。  

每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的副本，并与父进程共享代码段。  

每一个副本都是独立的，子进程对属于它的 副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。  

全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高常见进程下效率。  

不过，新建的子基础讷航也可以通过系统的调用函数exec把一个新的程序加载到自己的内存中，而原先在其内存中的数据段、堆、栈、代码段都会被替换掉为新程序对应的数据。

Unix系系统每个进程都有父进程，死哦you进程组成了进程树状结构，内核启动基础讷航是进城树的根。

#### 3.3 进程的标识

为了方便管理进程，内核必须详细记录每个进程的属性和行为，即：优先级、状态、虚拟地址范围、访问权限等，这些信息都记录在进程的描述符中（一种复杂的数据结构）。  

保存在进程描述符中的进程ID（常称为PID）是进程在操作系统中的唯一标识，其中进程ID为1的进程即为内核启动进程。进程ID是一个非负整数且总是顺序的编号，新建进程ID是钱一个进程ID递增的结果。当然，进程ID也可以重复使用。当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个座位新进程的ID，另外，进程描述符中还会包含当前进程的父进程ID(常称为PPID，通常可以据此找到守护进程踪迹)。  

Go中获取当前进程的ID和PPID：
```go
pid := os.Getpid()
ppid := os.Getppod()
```

#### 3.4 进程的状态

通常Linux的进程状态有6种：  

可运行状态（简称R：TASK_RUNNING）：表示需要立刻要在或正在CPU上运行，但是运行的时机不确定，由进程调度器决定  

可中断的睡眠状态(简称S：TASK_INTERRUPTIBLE)：当进程中横在等待某个事件到来时（如网络连接、信号量），会进入此状态，这样的进程会被放入对应事件的等待队列中，当事件发生时hihi，对应的等待对流中一个或多个进程就会被唤醒。  

不可中断的睡眠状态(简称D：TASK_UNINTERRUOTIBLE):不可被中断，即意味着该状态的进程不会对任何信号做出响应，其实，发送给此状态的进程的信号会在进程状态转出时才传递过去。处于该状态的进程通常是在等待一个特殊的事件，比如等待IO。  

暂停状态/跟踪状态(简称T:TASK_STOPPED/TASK_TRACED):向进程发送SIGSTOP信号，就会使进程进入该状态，注意：进程处于不可中断状态，发送该信号无效，进程处于暂停状态，发送该信号会使该进程转向可运行状态。处于该状态的进程会暂停，并等待另一个进程（跟踪它的进程）对它进行操作。  

僵尸状态(简称Z：TASK_DEAD-EXIT_ZOMBIE)：处于此状态的进程即将结束运行，该进程占用的绝大多数资源也都已经被回收，不过还有一些信息未被删除，如退出码、统计信息等，因为父进程可能需要他们。  

退出状态(简称X：TASK_DEAD-EXIT-DEAD)：在进程退出时，可能连退出码和统计信息都不需要保留，造成这种情况的原因可能是显式的让该进程的父进程忽略掉SIGCHLD信号（当一个进程即将消亡的时，内核会向其父进程发送SIGCHLD信号告知情况），也可能是该进程已经被分离（父子进程分别独立运行），分离后的子程序不会再使用和执行与父进程共享的代码段中的指令，而是加载并运行一个全新的程序，在这些情况下，该进程在退出的时候就不会转入僵尸状态，而是直接转入退出状态。处于退出状态的进程会被立即销毁。 

进程在其声明周期内会产生一系列变化，即进程的状态只会在可运行状态和非可运行状态之间转换。  

#### 3.5 进程的空间 

用户进程（即程序执行的实例）总会生存在用户空间中，不能与计算机硬件交互，只有内核可以 ，但是内核位于内核空间，用户进程无法访问内核空间。  





#### 进程的通信

在多进程程序中，多个进程之间经常需要协作完成任务，那么进程间的通信方式显得格外重要，这种通信方式成为IPC。  

IPC方式分类：
- 基于通信：又分为两类
    - 以数据传送为手段：包括管道（pipe：负责传送字节流）、消息对垒（message queue：负责传送结构化对象）
    - 以共享内存为手段：主要是共享内存区(shared memeory)，是最快的IPC方法
- 基于信号：即常说的操作系统的信号机制（signal），是唯一的一种异步IPC方法
- 基于同步：常见的是基于信号量(semaphore)

