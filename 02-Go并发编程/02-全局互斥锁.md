## 一 全局互斥锁 
不同的goroutine间通讯方式之间有两种通讯方式：
- 全局变量的互斥锁-不推荐，适用于等待一组go协程的退出
- 使用channel解决
全局互斥锁案例：计算1-20的各个数的阶乘，并存储在map中。
```go
package main
import (
	"fmt"
	"time"
)

var factorialMap = make(map[int]int, 10)
func factorial(num int) {
	res := 1
	for i := 1; i <= num; i++ {
		res *= i
	}
	factorialMap[num] = res
}

func main() {

	for i := 1; i <= 20; i++ {
		go factorial(i)
	}

	//休眠10秒钟后，看结果
	time.Sleep(time.Second * 10)
	for i, v := range factorialMap {
		fmt.Printf("map[%d]=%d\n", i, v) 
	}

}
```
由于上述代码没有对全局变量factorialMap加锁，因此会出现资源争夺问题，代码会出现错误，提示
```
fatal error: concurrent map writes
```
调整后的代码：
```go
package main
import (
	"fmt"
	"time"
	"sync"
)

var (
	factorialMap = make(map[int]int, 10)
	lock sync.Mutex				//全局互斥锁lock，sync：同步，Mutex：互斥
)
func factorial(num int) {
	res := 1
	for i := 1; i <= num; i++ {
		res *= i
	}
	lock.Lock()					//加锁
	factorialMap[num] = res
	lock.Unlock()				//解锁
}

func main() {

	for i := 1; i <= 20; i++ {
		go factorial(i)
	}

	//休眠10秒钟后，看结果
	lock.Lock()
	time.Sleep(time.Second * 10)
	for i, v := range factorialMap {
		fmt.Printf("map[%d]=%d\n", i, v) 
	}
	lock.Unlock()

}
```

等待多个协程退出案例：
```go
package main 

import (
	"fmt"
	"time"
	"sync"
)

func main() {
	
	
var wg sync.WaitGroup
	wg.Wait()
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(i int, wg *sync.WaitGroup) {
			fmt.Println("go协程开始", i)
			time.Sleep(2 * time.Second)
			wg.Done()
			fmt.Println("go协程结束", i)
		}(i, &wg)
		wg.Wait()
		fmt.Println("所有go协程操作完毕")
	}
}

```