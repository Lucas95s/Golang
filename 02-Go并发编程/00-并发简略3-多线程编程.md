## 一 线程

#### 1.1 线程概述

线程可以视为某个进程内部的控制流，其包括：
- 主线程：随着进程的启动而创建，必定拥有，因为进程必须有一个控制流持续运行。
- 其他线程：不一定拥有，由主线程或者其他线程创建（调用pthread_create函数）  

当拥有多个线程时，可以并发执行多个任务，即使某个任务被阻塞，也不会影响其他任务正常执行。  

注意：
- 线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期  
- 与进程不同，线程不存在父子级别关系，同一进程中的任意2个线程之间的关系是平等的

线程自己私有的数据都存储在线程栈中，线程栈位于所属进程的虚拟内存地址中。不过，一个进程的很多资源会被所有线程共享，比如：代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符等。所以，同一进程中的多个线程运行的一定是同一个程序，只不过具体的控制流和执行的函数可能不同。也正因如此，同一进程内的多线程共享数据变得很轻松，创建新线程也无需再复制资源了。

#### 1.2 线程标识

每个线程也有属于自己的ID，称为TID，只在其所属的进程范围内唯一。  

注意：Linux中的线程ID在系统范围内也是唯一的，且线程不存在后，该ID可被其他线程复用。  

#### 1.3 线程终止与分离

线程可以通过多种方式终止同一进程中的其他线程，常用方式是调用pthread_cancel：该函数执行后立即返回，不会等待线程做出的响应结果。  

如果一个线程可以被连接，其终止时必须连接，否则会成为僵尸线程，这样会导致资源浪费。如何连接处于终止中的线程呢？使用pthread_join函数执行。  

默认情况下，线程都是可以被连接的，但是将线程分离后（pthread_detach），则线程不可被连接，且内核将在线程终止时执行清理和销毁，分离操作不可逆。
  
#### 1.4 线程调度

进程之间存在着树形关系，线程不同，任何线程都可以对同一进程的其他线程进行有限的管理。

调度器会把事件划分为极小的时间片并把这些时间片分配给不同的线程，以使众多线程都有机会在CPU上运行，也造成了我们多线程被并行运行的幻觉。

## 二 线程同步-互斥方式

#### 2.1 共享数据一致性

一个程序一般包含多个线程，线程间往往通过共享数据的方式传递数据。共享数据大多存放在共享内存中。在多线程开发中，我们总是设法保证共享数据的一致性，除非该数据永远只被一个线程访问。  

保证共享数据一致性的最简单和最彻底的方法就是使该数据编程一个不变量，在编程语言中可以使用常量来确保。但是类似计数器这样的数据变成常量是不现实的，必须通过额外手段来保证被多个线程共享变量的一致性，这就有了临界区的概念。  

临界区是只能被串行化访问或执行的某个资源或某段代码，常称为串行区域。一般通过同步机制来保证临界区有效，常见的同步机制有：原子操作、互斥量、条件变量等。

#### 2.2 互斥量

互斥（metex）：在同一时刻，只允许一个线程处于临界区内。  

互斥量：线程将对象锁定后，才能进入临界区，否则线程就会阻塞，这个对象我们称之为互斥对象或者互斥量。  

由此可知，互斥量有已锁定、未锁定两种状态，且一旦被锁，则不能再次锁定，只有解锁后才能再次锁定（即不允许别的线程二次加锁）。多个线程为了能够访问临界区，将会争夺锁的所有权。  

线程在离开临界区的时候，必须对互斥量进行解锁，此时其他想进入该临界区的线程将会被唤醒再次争夺锁。  

在一般情况下，应该尽量少的使用互斥量，每个互斥量保护的临界区应该在合理范围内并晶亮大，如果多个线程频繁出入某个较大的临界区，且经常存在访问冲突，应该把该临界区切分为若干较小的临界区，并使用不同的互斥量加以保护。这样能降低线程被阻塞的概率，提升性能。  

#### 2.3 死锁

尽量不要让不同的互斥量锁保护的临界区重叠。不同的互斥量保护的临界区中包含了对同一个共享资源的同一种操作，此时会产生死锁。  

解决死锁的办法有两种：
- 试锁定-回退：操作系的线程库中提供了该功能。在执行一个代码块时，需要先后锁定多个互斥量，成功锁定其中一个互斥量后应该使用试锁定的方法来锁定后续一个互斥量，如果后续任一互斥量锁定失败，则解锁刚才被锁的互斥量，重新进行争夺锁尝试。注意：多个互斥量被成功加锁后，解锁顺序和加锁顺序相反，这样可以减少回退次数。
- 固定顺序锁定：举例，线程A和线程B总是先锁定互斥量1，再锁定互斥量2，那么就不会产生死锁。

第一种方案更加有效，但是程序变得复杂了，后一种方法简单实用，但是因为存在固定顺序，降低了程序的灵活性。  

## 三 线程同步-条件变量方式


条件变量不从临界区的线程访问数量上入手，而是在对应的共享数据状态发生变化时，通知其他被阻塞线程。条件变量一般与互斥量组合使用。  

互斥量有时候也不能完美解决问题，比如： 
```
有一个数据队列，存在着生产者线程、消费者线程对该队列数据的使用，使用互斥量保护该数据队列，生产者线程添加数据，消费者线程消费数据。  

如果生产者线程获得互斥量，发现数据队列已满，无法添加新数据，这时生产者线程可能就会在临界区等待，直到有空闲区间，这种做法明显是错误的，应该在发现没有空闲区间时直接解锁退出。  

同样消费者线程获取锁后，发现数据队列为空，则也会一直等待，我们也推荐发现为空后直接解锁。
```

条件变量和互斥量配合可以解决上述问题，条件变量有三种操作：
- 等待通知（wait）：如果当前数据状态不满足条件，则解锁与该条件变量绑定在一起的互斥量，然后阻塞当前线程，直到收到该条件变量发来的通知
- 单发通知（signal）：让条件变量向至少一个正在等待它通知的线程发送通知，以表示共享数据状态发生了改变 
- 广播通知（broadcast）：给等待通知的所有线程发送通知



#### 四 多进程与多线程利弊

交换数据：多进程交换数据方式复杂（管道、消息队列、信号量、共享内存），多线程之间交换数据很简单，但会产生竞态条件，需要解决同步问题。

综合而言，多线程方式具备大量优势，但是在处理信号、同时运行多套不同程序以及包含多个需要超大内存支持的任务等，多进程方式更适合。  

#### 五 多核CPU并发编程

在单核CPU上，每一时刻，只有1个线程在运行，而在多核CPU上，操作系统会对CPU进行调度，会让人感觉有多个线程在同时运行，这时只能算是并发运行。  

- 并发运行：多个任务同时被发起，但同一时刻这些任务不一定都处于运行状态
- 并行运行：同一时刻有多个任务在真正的同时执行，其必要天监事多核心CPU

其实增加CPU核心数，并发程序的运行速度提升曲线会随着CPU数量的增加而逐渐趋于平缓增加。因为这种趋于平缓的态势取决于程序中使用同步方法的数量和执行耗时，越多则平滑态势越明显。  

针对以上问题，给出的开发建议如下：
- 控制临界区纯度：尽量不要把无关代码尤其是I/O操作（包括打印函数）放置在临界区
- 控制临界区粒度：如果存在相邻的多个临界区，内部都是操作同一个共享数据代码，可以合并他们
- 降低临界区代码耗时：比如使用合理的算法
- 避免长时间持有互斥量：比如使用条件变量
- 优先使用原子操作而不是互斥量：因为原子操作是直接利用硬件级原语保证并发安全









