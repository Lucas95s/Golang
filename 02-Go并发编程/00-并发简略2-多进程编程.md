## 一  多进程编程

#### 1.1 进程的定义 

所有的代码都是在进程中执行的，进程是UNIX系操作系统的根本。我们常把一个程序的执行成为一个进程，即进程是用来描述程序的执行过程。  

进程是操作系统进行资源分配的基本单位。

#### 1.2 进程的衍生

使用操作系统的调用函数for可以创建若干个新的进程，调用者称为父进程，被创造出来的进程称为子进程。  

每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的副本，并与父进程共享代码段。  

每一个副本都是独立的，子进程对属于它的 副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。  

全盘复制父进程的数据相当低效，Linux使用写时复制（COW：Copy on Write）技术来提高常见进程下效率。  

不过，新建的子基础讷航也可以通过系统的调用函数exec把一个新的程序加载到自己的内存中，而原先在其内存中的数据段、堆、栈、代码段都会被替换掉为新程序对应的数据。

Unix系系统每个进程都有父进程，死哦you进程组成了进程树状结构，内核启动基础讷航是进城树的根。

#### 1.3 进程的标识

为了方便管理进程，内核必须详细记录每个进程的属性和行为，即：优先级、状态、虚拟地址范围、访问权限等，这些信息都记录在进程的描述符中（一种复杂的数据结构）。  

保存在进程描述符中的进程ID（常称为PID）是进程在操作系统中的唯一标识，其中进程ID为1的进程即为内核启动进程。进程ID是一个非负整数且总是顺序的编号，新建进程ID是钱一个进程ID递增的结果。当然，进程ID也可以重复使用。当进程ID达到最大限额值时，内核会从头开始查找闲置的进程ID并使用最先找到的那一个座位新进程的ID，另外，进程描述符中还会包含当前进程的父进程ID(常称为PPID，通常可以据此找到守护进程踪迹)。  

Go中获取当前进程的ID和PPID：
```go
pid := os.Getpid()
ppid := os.Getppod()
```

#### 1.4 进程的状态

通常Linux的进程状态有6种：  

可运行状态（简称R：TASK_RUNNING）：表示需要立刻要在或正在CPU上运行，但是运行的时机不确定，由进程调度器决定  

可中断的睡眠状态(简称S：TASK_INTERRUPTIBLE)：当进程中横在等待某个事件到来时（如网络连接、信号量），会进入此状态，这样的进程会被放入对应事件的等待队列中，当事件发生时hihi，对应的等待对流中一个或多个进程就会被唤醒。  

不可中断的睡眠状态(简称D：TASK_UNINTERRUOTIBLE):不可被中断，即意味着该状态的进程不会对任何信号做出响应，其实，发送给此状态的进程的信号会在进程状态转出时才传递过去。处于该状态的进程通常是在等待一个特殊的事件，比如等待IO。  

暂停状态/跟踪状态(简称T:TASK_STOPPED/TASK_TRACED):向进程发送SIGSTOP信号，就会使进程进入该状态，注意：进程处于不可中断状态，发送该信号无效，进程处于暂停状态，发送该信号会使该进程转向可运行状态。处于该状态的进程会暂停，并等待另一个进程（跟踪它的进程）对它进行操作。  

僵尸状态(简称Z：TASK_DEAD-EXIT_ZOMBIE)：处于此状态的进程即将结束运行，该进程占用的绝大多数资源也都已经被回收，不过还有一些信息未被删除，如退出码、统计信息等，因为父进程可能需要他们。  

退出状态(简称X：TASK_DEAD-EXIT-DEAD)：在进程退出时，可能连退出码和统计信息都不需要保留，造成这种情况的原因可能是显式的让该进程的父进程忽略掉SIGCHLD信号（当一个进程即将消亡的时，内核会向其父进程发送SIGCHLD信号告知情况），也可能是该进程已经被分离（父子进程分别独立运行），分离后的子程序不会再使用和执行与父进程共享的代码段中的指令，而是加载并运行一个全新的程序，在这些情况下，该进程在退出的时候就不会转入僵尸状态，而是直接转入退出状态。处于退出状态的进程会被立即销毁。 

![](/images/Golang/进程-02.png)

进程在其声明周期内会产生一系列变化，即进程的状态只会在可运行状态和非可运行状态之间转换。  

#### 1.5 进程的空间 

用户进程（即程序执行的实例）总会生存在用户空间中，不能与计算机硬件交互，只有内核可以 ，但是内核位于内核空间，用户进程无法访问内核空间。  

内存区域中的每一个单元都是有地址的，这些地址由指针来标识和定位，通过指针来寻找内存单元的操作也称为内存寻址。  

指针是一个正整数，由若干二进制位标识，其数量由CPU决定，32位可以标识出2^32个内存单元，64则是64次方个。  

这里的地址并非物理内存中的真实地址，而是虚拟地址，由虚拟地址标识出的内存区域称为虚拟内存。用户虚拟地址的范围是0-TASK_SIZE，内核空间占据剩余部分。内核为每个用户进程分配的也都是虚拟内存。进程的虚拟空间之间都是彼此独立，互不干扰的。

#### 二 系统调用

#### 2.1 内核态与用户态 

用户进程无法操作计算机硬件，内核空间可以，内核会暴露一些接口提供给用户进程使用。这些接口是用户空间和内核空间之间的桥梁。我们常说的系统调用其实就是用户进程使用这些接口的行为。  

内核为了保证系统的安全和稳定，为CPU特供了两个状态：内核态与用户态。  
- 用户态：大部分时间CPU处于该状态，此时只能访问用户空间
- 内核态：当用户进程发起系统调用（即操作刚才所说的接口），内核会将CPU切换到内核态，然后执行相应接口函数。

#### 2.7 进程的切换和调度-上下文切换

操作系统可以在在多个进程之间来回切换，产生多个进程同时运行的假象，每个进程都会认为自己独占了CPU，这就是多任务操作系统的由来。但是无论切换速度如何，同一时刻正在运行的进程仅会有一个。  

切换进程是有代价的，必须保存进程的运行时状态。


## 四 进程通信

#### 4.1 进程的通信方式

在多进程程序中，多个进程之间经常需要协作完成任务，那么进程间的通信方式显得格外重要，这种通信方式称为IPC。  

IPC方式分类：
- 基于通信：又分为两类
    - 以数据传送为手段：包括管道（pipe：负责传送字节流）、消息对垒（message queue：负责传送结构化对象）
    - 以共享内存为手段：主要是共享内存区(shared memeory)，是最快的IPC方法
- 基于信号：即常说的操作系统的信号机制（signal），是唯一的一种异步IPC方法
- 基于同步：常见的是基于信号量(semaphore)

#### 4.2 同步

很多场合下，多个进程之间要相互配合完成同一个任务，此时需要IPC支持。此时会遇到一个严重问题，无论是多CPU、多进程还是多线程，都存在数据共享时的同步问题。  

竞态条件：多个进程同时对同一个资源进行访问。比如：某一个数据，进程A对其进行执行`一系列`操作，但是在执行过程中，系统有可能会切换到另外一个进程B中，B也对该数据进行`一系列`操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？  

造成竞态条件的根本原因在于：进程在进行某些操作时被操作系统切换出去，中断了当前任务！虽然进程再次恢复时，状态还和以前一样，但是外部环境可能在这极短的时间内发生了改变。  

原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。同时，这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go中(sync/atomic包提供了原子操作函数)。  

注意：
- 所有的系统调用都是原子操作，即不用担心它们的执行被中断！
- 原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。 
- 现在的CPU都提供了原子操作支持，即使是多核CPU、多CPU系统中，也能保证原子操作

问题：如果一个原子操作无法结束，现在也无法中断，如何处理？  
答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。  

互斥锁:在实际开发中，让串行化执行的代码形成临界区的做法比原子操作更加通用，这种只有一个进程/线程在临界区的做法称为互斥锁（exclusion principle）。这种做法应该不依赖于的计算机硬件，IPC方法之一的信号量是实现互斥方法的方式之一，Golang的sync包也有对互斥的支持。  

#### 4.3 信号

信号是IPC中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制。信号用来通知某个进程有某个事件发生了，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go中的ginal包提供了相关操作。  

#### 4.4 socket

socket即套接字，也是一种IPC方法，与其他IPC方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。  

在Linux中，存在一个名为socket的系统调用:
```
int socket(int domain, int type, int protocol);
```
该系统调用会创建一个socket实例，参数分别为：通信域，类型，协议。  

通信域决定socket的地址格式、通信范围，常用的有：
- AF_INET: IPv4地址（4字节）+ 端口号（2字节）
- AF_INET6: IPv6地址（16字节）+ 端口号（2字节）
- AF_UNIX: Unix域，地址形式不再是上述IP，而是路径名，用于同一台计算机的两个应用程序通信

类型：
- SOCK_DGRAM: 数据报形式，有数据边界，没有逻辑连接，不保证数据有序性，不具备传输可靠性
- SOCK_RAW: 数据包形式，有数据边界，没有逻辑连接，不保证数据有序性，不具备传输可靠性
- SOCK_SEQPACKET: 字节流形式，有数据边界，有逻辑连接，能保证数据有序性，具备传输可靠性
- SOCK_STREAM: 字节流形式，没有数据边界，有逻辑连接，能保证数据有序性，具备传输可靠性

数据的形式有两种：
- 数据报：接收方的socket接口可以识别数据边界，并对其进行拆分，省去了接收方应用寻找数据边界和切分数据的工作量
- 字节流：传输的是一个字节接着一个字节的串，可以列为一个很长的字节数组，字节流不能体现出哪些字节属于哪个数据报。因此socket接口程序无法从中分离出独立的数据报，这一工作由应用程序本身完成。当然，SOCK_SEQPACKET类型例外，它可以实时记录数据边界。

有连接和无连接：
- 有连接：必须先建立逻辑连接才能互相传输数据，连接中暗含了双方地址，传输时不必指定目标地址。
- 无连接：传输数据无需建立连接，每个数据报都是独立的，直接发送到网络上，数据包中含有目标地址，以传输到不同的地方。无连接的socket的数据流都是单向的，即不能实现既发送又接收。

数据的可靠性、有序性与socket是否面向连接有很大关系，因为逻辑连接的存在，才能使数据的传输及时、正确、有序。  

协议：TCP/IP,UDP两种  

socket调用的返回值一般是一个int类型的值，该值是socket实例唯一标识符的文件描述符。有了该标识符，就可以调用其他系统方法来进行绑定监听端口、发送接收数据、关闭socket等操作。  

贴士：
- socket接口程序和TCP/IP协议的实现程序一样，都是Linux内核的一部分。  
- Golang的socket编程API为我们屏蔽了底层，使得其看起来API调用像是阻塞的，其实底层使用的是非阻塞式的socket接口





















