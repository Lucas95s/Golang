## 一 并发模型

#### 1.1 并发与并行

并行：任意粒度的时间内都具备同时执行的能力，最简单的并行就是多机，多台机器并行处理。  

并发：规定时间内多个请求都得到执行和处理，强调的是给外界的感觉，实际上内部可能是分时操作的。并发重在避免阻塞，使程序不会因为一个阻塞而停止。


并发解决方案：
- 多进程:在操作系统层面并发，由于由系统内核管理，操作简单、进程互不影响，但是开销最大，占用资源较多，能开启的进程数也比较少，
- 多线程:多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存在死锁管理问题。
- 非阻塞IO:基于回调的异步非阻塞IO，尽可能少的运用线程，见Node.js
- 协程:本质上是用户态线程，不需要系统进行抢占式调度，且真正的实现寄存于线程中，开销极小。

#### 1.2 关于进程

在操作系统运行过程中，可以产生很多进程，在unix/linux系统中，正常情况下，子进程是通过父进程fork创建的，子进程再创建新的进程。父进程无法预测子进程到底什么时候结束，当一个进程完成它的工作终止后，它的父进程需要调用系统取得子基础南横终止态。  

多进程容易产生的问题：  

孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，其父进程变成了系统最开始的init进程，称为init进程领养孤儿进程。  

僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。

#### 1.3 线程

注意：在win下只有线程。
线程是Linux为了模仿，基于进程开启的轻量级进程，与进程一样拥有独立的PCB，但是没有独立的地址空间，地址空间是共享的。  

共享地址空间：
![](/images/Golang/线程.png)

如图得出：
- 线程：系统最小的执行单位，即cpu分配时间轮片的对象
- 进程：系统最小的资源分配单位

线程同步：同步即按预定的先后次序运行，线程发出某一个功能调用时，在没有得到结果之前，该调用不返回，且其他线程为保证数据一致性，不能调用该功能。线程同步是为了避免引起数据混乱，解决与时间有关的错误，实际上，进程，线程，信号之间都需要同步机制。 

总结：多个控制流，共同操作一个共享资源，都需要同步。

#### 二 协程

协程：协程的优势在于其轻量级，可以轻松创建上百万个协程而不会造成系统资源衰竭。  

线程需要上下文不停切换，协程不会主动交出使用权，除非代码中主动要求切换，或者发生IO。（主动切换函数：runtime.Gosched）  

这样如果没有主动切换、IO，那么协程一直运行下去，遇到IO，则立即切换到被的协程，很好的解决了并发编程。  

Go直接从语言层面支持了并发，goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过`go`关键字实现了，其实就是一个普通的函数。
案例：
```Go
func say(s string) {
	for i := 0; i < 5; i++ {
		runtime.Gosched()
		fmt.Println(s)
	}
}

func main() {
	go say("world") //开一个新的Goroutines执行
	say("hello") //当前Goroutines执行
}

// 以上程序执行后将输出：
// hello
// world
// hello
// world
// hello
// world
// hello
// world
// hello

```
> runtime.Gosched()表示让CPU把时间片让给别人,下次某个时候继续恢复执行该goroutine。
> 默认情况下，在Go 1.5将标识并发系统线程个数的runtime.GOMAXPROCS的初始值由1改为了运行环境的CPU核数。
但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要在我们的程序中显式调用 runtime.GOMAXPROCS(n) 告诉调度器同时使用多个线程。GOMAXPROCS 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果n < 1，不会改变当前设置。  
Go协程的特点：
- 有独立的栈空间
- 共享程序堆空间
- 调度由用户控制
- 协程是轻量级的线程
注意：如果主线程退出了，则协程及时还没有执行完毕也退出  

## 二 并发模型  

#### 2.1 常见并发模型
 
在工程上，有两种常见并发模型：共享数据和消息。共享数据最常见的是共享内存。
多线程共享内存：
线程加共享内存的方式归纳为 共享内存系统。线程间共享状态的各种操作都被封装在线程之间的传递消息中。这就需要：发送消息时，对状态进行复制，并且在消息传递的边界上交出这个状态的所有权。由于复制的存在，造成了性能问题。
Go使用消息机制而非共享内存作为通信方式。消息机制认为每个并发单元是自包含的、独立的个体，都有自己的变量，在不同并发单元间不共享，不同单元间输入输出只有消息，类似于进程间互不打扰。Go的这个使用方式称为channel。

#### 2.2 goroutine调度模型

MPG模式运行状态1：
![](/images/Golang/并发-01.png)
- M:操作系统的主线程（是物理线程），P:协程执行时需要的上下文，G：协程
- 上图中，当前程序有三个物理线程，如果三个物理线程都在同一个CPU运行，就是并发，否则是并行。
- Go的协程是轻量的逻辑态的，Java的多线程是重量的内核态的，几千个线程可能会耗光CPOU

#### 2.3 设置Golang运行cpu数

在Go1.8之后，程序默认运行在多核上，无需设置，1.8之前需要如下设置：
```go
package main

import (
	"runtime"
	"fmt"
	"time"
)


func main() {

	cpuNum := runtime.NumCPU()			//获取当前系统的CPU核心数

	count := 0

	fmt.Println("CPU数：", cpuNum)

	runtime.GOMAXPROCS(4)				//Go中可以轻松控制使用核心数

	for i := 0; i < 10; i++ {
		go func(){
			for {
				count++
			}
		}()
	}

	time.Sleep(time.Hour)

}
```

#### 2.4 常用包

runtime.Gosched():用于让出CPU时间片，让出当前协程的执行权限，调度器安排其他等待的任务运行。（可以理解为接力赛跑：A跑了一段遇到了Gosched接力给B）。  

runtime.Goexit():用于立即终止当前协程运行，调度器会确保所有已注册defer延迟调用被执行。  

runtime.GOMAXPROCS():用来设置可以并行计算的CPU核心数最大值，并返回之前的值。

## 三 Go中获取协程结果的办法

Go中可以使用全局互斥锁（不推荐）与channel的方式进行协程通信。
