## 二 集合map
#### 2.1 map的创建
Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。
```
	//map的简单创建
	//声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型
	m := map[string]int{"a":1,"b":2}
	fmt.Print(m["a"])
```

使用make方式创建map：
```
type Person struct{
	ID string
	Name string
}

func main() {

	var m map[string] Person				
	m = make(map[string] Person)
	m["123"] = Person{"123","Tom"}
	p,isFind := m["123"]
	fmt.Println(isFind)		//true
	fmt.Println(p)			//{123 Tom}

}
```
注意：key 可以是什么类型？
golang 中的 map，的 key 可以是很多种类型，比如 bool, 数字，string, 指针, channel , 还可以是只 包含前面几个类型的 接口, 结构体, 数组。  
通常 key 为 int 、string。  
注意: slice， map 还有 function 不可以，因为他们不能使用 == 来判断

#### 2.2 map的使用

map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。
```
// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
// 另一种map的声明方式
numbers = make(map[string]int)
numbers["one"] = 1 //赋值
numbers["ten"] = 10 //赋值
numbers["three"] = 3

fmt.Println("第三个数字是: ", numbers["three"]) // 读取数据
// 打印出来如:第三个数字是: 3
```
map的遍历：同数组一样，使用for-range 的结构遍历  

注意：
map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取；
map的长度是不固定的，也就是和slice一样，也是一种引用类型	
内置的len函数同样适用于map，返回map拥有的key的数量
map的值可以很方便的修改，通过numbers["one"]=11可以很容易的把key为one的字典值改为11
map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制

#### 2.3 删除元素
```
// 初始化一个字典
rating := map[string]float32{"C":5, "Go":4.5, "Python":4.5, "C++":2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating["C#"]
if ok {
    fmt.Println("C# is in the map and its rating is ", csharpRating)
} else {
    fmt.Println("We have no rating associated with C# in the map")
}

delete(rating, "C") // 删除key为C的元素
```
#### 2.4 mpa的安全问题
Go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map
