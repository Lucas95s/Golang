## 一 接口 interface
#### 1.1 接口定义
接口（interface）就是一组不需实现的方法声明，不能包含任何变量。到某个自定义类型要使用的时候,在根据具体情况把这些方法写出来(实现)。
接口示例：
```go
package main

import (
	"fmt"
)

//定义一个万能Usb接口
type Usb interface {
	//定义Usb的两个方法
	Insert()
	Remove()
}

//安卓连接
type Android struct {

}
//Android实现Usb接口
func(a Android) Insert() {
	fmt.Println("Android Usb接入成功")
}
func(a Android) Remove() {
	fmt.Println("Android Usb移除成功")
}

//Apple手机接口
type Apple struct {

}
//Apple实现Usb接口
func(p Apple) Insert() {
	fmt.Println("Apple Usb接入成功")
}
func(p Apple) Remove() {
	fmt.Println("Apple Usb移除成功")
}

//电脑
type Computer struct {

}
//电脑连接usb后工作 usb 变量会根据传入的实参，来判断到底是Android 还是 Apple
func (c Computer) Working(usb Usb) {
	usb.Insert()
	usb.Remove()
}

func main() {

	computer := Computer{}
	android := Android{}
	apple := Apple{}

	computer.Working(android)
	computer.Working(apple)
}
```
由上看出传入的实参是 android，但是其类型复合 Usb，也就是说在Go中，接口的实现原则是：  
只要实现了该接口的所有方法，该类型就是实现了某个接口。
注意：
- 接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例)
- 接口中所有的方法都没有方法体,即都是没有实现的方法
- 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型，一个自定义类型可以实现多个接口
- 一个接口(比如 A 接口)可以继承多个别的接口(比如 B,C 接口)，这时如果要实现 A 接口，也必 须将 B,C 接口的方法也全部实现。
- 空接口 interface{} 没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量 赋给空接口
接口与继承的区别：
```
接口和继承解决的解决的问题不同:
继承的价值主要在于:解决代码的复用性和可维护性。
接口的价值主要在于:设计，设计好各种规范(方法)，让其它自定义类型去实现这些方法。

比起继承，接口更加灵活（因为只要方法全部实现即可），同时，接口在一定程度上实现代码解耦。
```
#### 1.2 多态
在前面的Usb接口案例中，可以接收不同的实现了他的变量，就体现了多态。
#### 1.3 类型断言
类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言。
案例：当接入的是Apple接口时，我们还想自动呼出Siri，那么如何处理呢？  
```go
//Apple添加一个呼出Siri方法
func(p Apple) Siri() {
	fmt.Println("呼出Siri")
}

//电脑类型断言
func (c Computer) Working(usb Usb) {

	usb.Insert()

	if apple,ok := usb.(Apple); ok {
		apple.Siri()
	}

	usb.Remove()
}

```