## 一 类型系统
#### 1.1 Go中的面向对象
在Go中，可以给任意类型（除了指针）添加相应方法：
```
type Interger int

func (i Interger) Less (j Interger) bool {
	return i < j
}

func main() {
	var i Interger = 1
	fmt.Print(i.Less(5))
}
```
## 二 方法
#### 2.1 方法的定义
在某些情况下，我们要需要声明(定义)方法。比如 Person 结构体:除了有一些字段外( 年龄，姓名..),Person 结构体还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用方法才能完成。  
Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。  
方法的声明和调用：
```go
func (recevier type) methodName(参数列表) (返回值列表){ 
    //方法体
    return 返回值
}
```
示例代码：
```go
type Person struct {
	Name string
}

func (p Person) run() {
	fmt.Println(p.Name + " is running...")
}

func main() {

	var p Person
	p.Name = "tom"
	p.run()			//tom is running...

}
```
注意：
- 现在run方法已经和Person绑定了，只能Person类型的变量调用
- func (p Person) run() {} p 表示哪个 Person 变量调用，这个 p 就是它的副本, 这点和函数传参非 常相似。
- 变量调用方法时，调用机制和函数一样，但是该变量本身也会作为一个参数传递到方法(如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地质拷贝)
## 三 面向对象三大特性
#### 3.1 封装
封装(encapsulation)就是把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其
它包只有通过被授权的操作(方法),才能对字段进行操作。  
通过封装，可以：
- 隐藏实现细节
- 可以对数据进行验证，保证安全合理
封装的体现：对结构体中的属性进行封装；通过方法，包 实现封装。  
封装的实现步骤：
```
1   将结构体、字段(属性)的首字母小写(私有化)；
2   给结构体所在包提供一个工厂模式的函数，首字母大写，类似一个构造函数；
3   提供一个首字母大写的 Set 方法(类似其它语言的 public)，用于对属性判断并赋值：
    func (var 结构体类型名) SetXxx(参数列表) (返回值列表) {
        //加入数据验证的业务逻辑
        var.字段 = 参数 
    }
4) 提供一个首字母大写的 Get 方法(类似其它语言的 public)，用于获取属性的值：
    func (var 结构体类型名) GetXxx() {
        return var.age
    }
特别说明:在 Golang 开发中并没有特别强调封装，这点并不像 Java. 所以提醒学过 java 的朋友， 不用总是用 java 的语法特性来看待 Golang, Golang 本身对面向对象的特性做了简化的.
```
示例：
![](/images/Golang/语法-06.png)
```go
//person.go
package model

import "fmt"

type person struct {
	Name string
	age int			//年龄是隐私，不允许其他包访问
}

//工厂函数（类似构造函数）
func Person(name string) *person {
	return &person{
		Name: name,
	}
}

func (p *person) SetAge(age int) {
	if age > 0 && age < 150 {		//校验
		p.age = age
	} else {
		fmt.Println("年龄不合法")
	}
}

func (p *person) GetAge() int {
	return p.age
}

//main.go
package main

import (
	"./model"
	"fmt"
)

func main() {
	p := model.Person("Tom")
	p.SetAge(18)
	fmt.Println(p)
}
```
#### 3.2 继承
在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。
```go
package main

import (
	"fmt"
)

type Father struct {
	Name string
	age int
}
func (f *Father) run() {
	fmt.Println(f.Name + " like running...")
}

type Son struct {
	Father              //嵌套匿名结构体
}

func main() {

	var s Son

	//s.Father.Name = "Tom"
	//s.Father.age = 10     		//可以访问未导出属性
	//s.Father.run()          	//可以访问未导出方法

	//上述可以简写为：
	s.Name = "Tom"
	s.age = 10
	s.run()

}
```
注意：
- 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问 匿名结构体的字段和方法，可以通过匿名结构体名来区分。
- 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身 没有同名的字段和方法)，在访问时，就必须明确指定匿名结构体名字，否则编译报错。
- 如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。
#### 3.3 多重继承
如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承。
```go
package main

import (
	"fmt"
)

type Father1 struct {
	Name string
	age int
}
func (f *Father1) run() {
	fmt.Println(f.Name + " like running...")
}

type Father2 struct {
	Like string
}


type Son1 struct {
	Father1
	Father2
}

type Son2 struct {
	*Father1
	*Father2
}

func main() {

	s1 := Son1 {
		Father1{
			Name: "Tom",
			age: 10,
		},
		Father2{
			Like: "伏特加",
		},
	}

	fmt.Println(s1)

	s2 := Son2{
		&Father1{
			Name: "Tom",
			age: 10,
		},
		&Father2{
		 	Like: "伏特加",
		},
	}
	fmt.Println(*s2.Father1)

}
```
如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来
区分。为了保证代码的简洁性，建议大家尽量不使用多重继承。
#### 3.4 接口
接口（interface）就是一组不需实现的方法声明，不能包含任何变量。到某个自定义类型要使用的时候,在根据具体情况把这些方法写出来(实现)。
接口示例：
```go
package main

import (
	"fmt"
)

//定义一个万能Usb接口
type Usb interface {
	//定义Usb的两个方法
	Insert()
	Remove()
}

//安卓连接
type Android struct {

}
//Android实现Usb接口
func(a Android) Insert() {
	fmt.Println("Android Usb接入成功")
}
func(a Android) Remove() {
	fmt.Println("Android Usb移除成功")
}

//Apple手机接口
type Apple struct {

}
//Apple实现Usb接口
func(p Apple) Insert() {
	fmt.Println("Apple Usb接入成功")
}
func(p Apple) Remove() {
	fmt.Println("Apple Usb移除成功")
}

//电脑
type Computer struct {

}
//电脑连接usb后工作 usb 变量会根据传入的实参，来判断到底是Android 还是 Apple
func (c Computer) Working(usb Usb) {
	usb.Insert()
	usb.Remove()
}

func main() {

	computer := Computer{}
	android := Android{}
	apple := Apple{}

	computer.Working(android)
	computer.Working(apple)
}
```
由上看出传入的实参是 android，但是其类型复合 Usb，也就是说在Go中，接口的实现原则是：  
只要实现了该接口的所有方法，该类型就是实现了某个接口。
注意：
- 接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例)
- 接口中所有的方法都没有方法体,即都是没有实现的方法
- 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型，一个自定义类型可以实现多个接口
- 一个接口(比如 A 接口)可以继承多个别的接口(比如 B,C 接口)，这时如果要实现 A 接口，也必 须将 B,C 接口的方法也全部实现。
- 空接口 interface{} 没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量 赋给空接口
接口与继承的区别：
```
接口和继承解决的解决的问题不同:
继承的价值主要在于:解决代码的复用性和可维护性。
接口的价值主要在于:设计，设计好各种规范(方法)，让其它自定义类型去实现这些方法。

比起继承，接口更加灵活（因为只要方法全部实现即可），同时，接口在一定程度上实现代码解耦。
```
#### 3.5 多态
在前面的Usb接口案例中，可以接收不同的实现了他的变量，就体现了多态。
#### 3.6 类型断言
类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言。
案例：当接入的是Apple接口时，我们还想自动呼出Siri，那么如何处理呢？  
```go
//Apple添加一个呼出Siri方法
func(p Apple) Siri() {
	fmt.Println("呼出Siri")
}

//电脑类型断言
func (c Computer) Working(usb Usb) {

	usb.Insert()

	if apple,ok := usb.(Apple); ok {
		apple.Siri()
	}

	usb.Remove()
}

```