## 一 布尔类型

bool：只能存true/false，占据1个字节，不能转换为整型，0和1也不能转换为布尔

## 二 数值类型

#### 2.1 整数类型

整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。
Go里面也有直接定义好位数的类型：rune，int8，int16，int32，int64，byte，uint8，uint16，uint32，uint64，其中rune是int32的别称，byte是uint8的别称。

```
int（有符号类型），32位系统占据4个字节（范围和int32一样），64位系统占据8个字节（范围和int64一样）     
int8    占据1字节   范围 -128 ~ 127
int16   占据2字节   范围 -2(15次方) ~ 2（15次方）-1
int32   占据4字节   范围 -2(31次方) ~ 2（31次方）-1
int64   占据8字节   范围 -2(63次方) ~ 2（63次方）-1
rune(有符号类型)，与int32一样，表示一个Unicode码

uint（无符号类型），32位系统占据4个字节（范围和uint32一样），64位系统占据8个字节（范围和uint64一样）     
uint8   占据1字节   范围 0 ~ 255
uint16  占据2字节   范围 0 ~ 2（16次方）-1
uint32  占据4字节   范围 0 ~ 2（32次方）-1
uint64  占据8字节   范围 0 ~ 2（64次方）-1
byte（无符号类型），与unit8等价，用于存储字符
```

注意：
- 上述类型的变量之间不允许互相赋值或操作，且int的长度是32 bit, 但int 与 int32并不可以互用。
- Go默认的整型类型是int
- 查看数据所占据的字节数方法：unsafe.Sizeof()


#### 2.2 浮点类型

浮点类型的分类
```
float32 单精度  占据4字节   范围 -3.403E38 ~ 3.403E38
float64 双精度  占据8字节   范围 -1.798E208 ~ 1.798E308
```

由上看出：
- 浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位  
- 浮点型的范围是固定的，不受操作系统限制
- .512 这样数可以识别为 0.512
- 科学计数法：5.1234e2 = 5.12 * 10 的 2 次方 5.12E-2 = 5.12/10 的 2 次方


精度损失：
```go
	var num1 float32 = -123.0000901
	var num2 float64 = -123.0000901 
	fmt.Println("num1=",num1)		//-123.00009
	fmt.Println("num2=",num2)		//-123.0000901
```

由上看出float64的精度要比float32要准确，一般使用float64

使用 == 号判断浮点数，是不可行的，替代方案如下：
```
func isEqual(f1,f2,p float64) bool {
   return math.Abs(f1-f2) < p           //p为用户自定义精度，如：0.00001
}
```

#### 2.3 复数

Go还支持复数。它的默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。
如下所示：
```
var t complex128
t = 2.1 + 3.14i
t1 = complex(2.1,3.14) //结果同上	
fmt.Println(real(t))   //实部：2.1
fmt.Println(imag(t))   //虚部：3.14
```

## 三 字符型

Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  
字符类型可以以d%打印为整型。
```go
	var c1 byte = 'a'
	var c2 byte = '0'

	fmt.Println("c1=", c1)					//输出 97
	fmt.Println("c2=", c2)					//输出48
    fmt.Printf("c1=%c,c2=%c\n", c1, c2)	    //输出原值 a 0

    //var c3 byte = '北'
	//fmt.Printf("c3=%c", c3)					//溢出错误
```

说明：
- 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte
- 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存
- 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1)
- 字符可以和整型进行运算


## 四 字符串

#### 4.1 基本使用

字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。  

字符串在Go语言中是基本类型，内容在初始化后不能修改。Go中的字符串都是采用UTF-8字符集编码，使用一对双引号（""）或反引号` `定义。  

使用``可以额外解析换行，即其没有字符转义功能。

```
   str := "Hello "
    str2 := " World!"
    // str[0] = 'c'         //编译报错： cannot assign to 因为字符串不可变
    fmt.Println(str[0])     //输出字符串第一个字符 72
    fmt.Println(len(str))   //输出长度 6
    fmt.Println(str + str2) //输出不带空格的
```

#### 4.2 字符串修改

Go中的字符串不可改变，有两种修改办法：

办法一：转换为[]byte类型
```
	str := "hello"
	strTemp := []byte(str)
	strTemp[0] = 'c';
	strResult := string(strTemp)
```

办法二：字符串可以进行切片操作
```
	str := "hello"
	str = "c"+ str[1:]
```

#### 4.3 字符串遍历

遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节
```
	str := "hello"
	for i := 0; i < len(str); i++ {
		fmt.Println(i,str[i])
	}
```

遍历方式二：使用Unicode字符遍历。range关键字只是第一种遍历方式的简写
```
	str := "hello"
	for i,ch := range str {
		fmt.Println(i,ch)
	}
```

#### 4.4 字符串转换

字符串转化的函数在strconv中，如下也只是列出一些常用的：

- Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中。

```Go

package main

import (
	"fmt"
	"strconv"
)

func main() {
	str := make([]byte, 0, 100)
	str = strconv.AppendInt(str, 4567, 10)
	str = strconv.AppendBool(str, false)
	str = strconv.AppendQuote(str, "abcdefg")
	str = strconv.AppendQuoteRune(str, '单')
	fmt.Println(string(str))
}
```

- Format 系列函数把其他类型的转换为字符串
```Go

package main

import (
	"fmt"
	"strconv"
)

func main() {
	a := strconv.FormatBool(false)
	b := strconv.FormatFloat(123.23, 'g', 12, 64)
	c := strconv.FormatInt(1234, 10)
	d := strconv.FormatUint(12345, 10)
	e := strconv.Itoa(1023)
	fmt.Println(a, b, c, d, e)
}

```

- Parse 系列函数把字符串转换为其他类型

```Go

package main

import (
	"fmt"
	"strconv"
)
func checkError(e error){
	if e != nil{
		fmt.Println(e)
	}
}
func main() {
	a, err := strconv.ParseBool("false")
	checkError(err)
	b, err := strconv.ParseFloat("123.23", 64)
	checkError(err)
	c, err := strconv.ParseInt("1234", 10, 64)
	checkError(err)
	d, err := strconv.ParseUint("12345", 10, 64)
	checkError(err)
	e, err := strconv.Atoi("1023")
	checkError(err)
	fmt.Println(a, b, c, d, e)
}

```

#### 4.5 其他操作

```
//判断str是否包含s
Contains(str, s string) bool
//通过字符串str连接切片 s
Join(s []string, str string) string
//查找s在字符串str中的索引
Index(str, s string) int
//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换
Replace(str,old,new string,n int) string
//字符串str按照s分割，返回切片
Splite(str,s string)[]string
//Append系列函数将整数等转换为字符串后，添加到现有的字节数组中
//Format系列函数可以把其他类型转换为字符串
//Trim函数可以去除头部、尾部指定的字符串
//Fields函数可以去除空格，返回切片
```

## 五 数组

#### 5.1 数组的声明

数组的长度定义后不可更改，长度使用 len() 获取。
声明方式：
```
	var arr1 [10]int					//定义长度为10的整型数组，很少这样使用
	arr2 [5]int := [5]int{1,2,3,4,5}	//定义并初始化
	arr3 := [5]int{1,2,3,4,5}			//自动推导并初始化
	arr4 := [5]int{1,2}					//指定总长度，前几位被初始化，没有的使用零值
	arr5 := [5]int{2:10, 4:11}			//有选择的初始化，没被初始化的使用零值
	arr6 := [...]int{2,3,4}				//自动计算长度
```

#### 5.2 数组常用操作

```
arr[:]      代表所有元素
arr[:5]     代表前五个元素
arr{5:}     代表从第5个开始，不包含第5个
len(arr)    数组的长度
```

#### 5.3 数组的遍历

方式一：for循环遍历
```go
	arr := [3]int{1,2,3}

	for i := 0; i < len(arr); i++ {
		fmt.Println(arr[i])
	}
```
方式二：for-range遍历
```go
	arr := [3]int{1,2,3}

	for i, v := range arr {
		fmt.Println(i)	//元素位置	
		fmt.Println(v)	//元素值
	}
```

#### 5.4 数组使用注意事项

数组创建完长度就固定，不可以再追加元素；
长度是数组类型的一部分，因此[3]int与[4]int是不同的类型；
数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。

## 六 结构体

#### 6.1 结构体的作用

结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体：
```go
	type Student struct {
		name string
		age int
	}

	//按顺序初始化：每个成员都必须初始化
	var s1 Student = Student{"lisi", 20}

	//制定成员初始化：没有被初始化的，自动赋零值
	s2 := Student{age:30}
	
	//new 申请结构体
	s3 := new(Student)
	s3.name = "zs"
	s3.age = 27
	
	//直接声明
	var s4 Student
	s4.name = "ww"
	s4.age = 30
```

struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放。
如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 > 和 <。
注意：如果结构体的成员要被包外调用，需要大写首字母。

#### 6.2 匿名字段

struct的字段名与类型一一对应，如果不提供名字，则为匿名字段。

如果匿名字段是一个struct时，这个struct拥有的全部字段都被隐式引入了当前的struct。

```
    type Human struct {
        name string
        age int
        weight int
    }
    
    type Student struct {
        Human // 匿名字段，那么默认Student就包含了Human的所有字段
        speciality string
    }
```
不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段：
```
    type Human struct {
        name string
        age int
        weight int
    }
    
    type Student struct {
        Human // 匿名字段，struct
        Skills // 匿名字段，自定义的类型string slice
        int // 内置类型作为匿名字段
        speciality string
    }
    
    func main() {
        // 初始化学生Jane
        jane := Student{Human:Human{"Jane", 35, 100}, speciality:"Biology"}
        // 现在我们来访问相应的字段
        fmt.Println("Her name is ", jane.name)
        fmt.Println("Her age is ", jane.age)
        fmt.Println("Her weight is ", jane.weight)
        fmt.Println("Her speciality is ", jane.speciality)
        // 我们来修改他的skill技能字段
        jane.Skills = []string{"anatomy"}
        fmt.Println("Her skills are ", jane.Skills)
        fmt.Println("She acquired two new ones ")
        jane.Skills = append(jane.Skills, "physics", "golang")
        fmt.Println("Her skills now are ", jane.Skills)
        // 修改匿名内置类型字段
        jane.int = 3
        fmt.Println("Her preferred number is", jane.int)
    }
```

这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？
Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过student.phone访问的时候，是访问student里面的字段，而不是human里面的字段。