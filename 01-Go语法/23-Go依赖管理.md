## 一 go mod 初步使用

go的项目依赖管理一直饱受诟病，在go1.11后正式引入了`go mod`功能，类似nodejs的npm。在go1.13版本中将会默认启用。  

使用Gomod可以让项目完全摆脱GOPATH的困扰。

`go mod` 初步使用：
```
# 开启go mod
export GO111MODULE=on

# 在新建的项目根目录下（src）下使用该命令
go mod init 项目名                      # 此时会生成一个go.mod文件

# 使用
在项目中可以随时import依赖，当 go run 时候，会自动安装依赖，比如：
import (
	"github.com/gin-gonic/gin"
)

```

go run 后的 go.mod:
```
module api_server

go 1.12

require (
	github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 // indirect
	github.com/gin-gonic/gin v1.3.0 // indirect
	github.com/golang/protobuf v1.3.1 // indirect
	github.com/mattn/go-isatty v0.0.7 // indirect
	github.com/ugorji/go/codec v0.0.0-20190320090025-2dc34c0b8780 // indirect
	gopkg.in/go-playground/validator.v8 v8.18.2 // indirect
	gopkg.in/yaml.v2 v2.2.2 // indirect
)
```

使用`go mod`后，run产生的依赖源码不会安装在当前项目中，而是安装在：`$GOPATH/pkg/mod`


## 二 详细使用
详细使用地址：https://zhuanlan.zhihu.com/p/59687626

## 三 翻墙下载问题

#### 3.1 推荐方式 GOPROXY

从 Go 1.11 版本开始，还新增了 GOPROXY 环境变量，如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。goproxy.io 这个开源项目帮我们实现好了我们想要的。该项目允许开发者一键构建自己的 GOPROXY 代理服务。同时，也提供了公用的代理服务 https://goproxy.io，我们只需设置该环境变量即可正常下载被墙的源码包了：

```
# linux开启代理
export GOPROXY=https://goproxy.io			# 注意：必须开启go mod才能使用

# win开启代理
$env:GOPROXY = "https://goproxy.io"

# 关闭代理
export GOPROXY=
```

#### 3.2 replace方式

从 Go 1.11 版本开始，新增支持了 go modules 用于解决包依赖管理问题。该工具提供了 replace，就是为了解决包的别名问题，也能替我们解决 golang.org/x 无法下载的的问题。

go module 被集成到原生的 go mod 命令中，但是如果你的代码库在 $GOPATH 中，module 功能是默认不会开启的，想要开启也非常简单，通过一个环境变量即可开启 export GO111MODULE=on。

```go
module example.com/hello

require (
    golang.org/x/text v0.3.0
)

replace (
    golang.org/x/text => github.com/golang/text v0.3.0
)
```

#### 3.3 手动下载 旧版go的解决
我们常见的 golang.org/x/... 包，一般在 GitHub 上都有官方的镜像仓库对应。比如 golang.org/x/text 对应 github.com/golang/text。所以，我们可以手动下载或 clone 对应的 GitHub 仓库到指定的目录下。

mkdir $GOPATH/src/golang.org/x
cd $GOPATH/src/golang.org/x
git clone git@github.com:golang/text.git
rm -rf text/.git
当如果需要指定版本的时候，该方法就无解了，因为 GitHub 上的镜像仓库多数都没有 tag。并且，手动嘛，程序员怎么能干呢，尤其是依赖的依赖，太多了。



