## 一 布尔类型

bool：只能存true/false，占据1个字节，不能转换为整型，0和1也不能转换为布尔

## 二 数值类型

#### 2.1 整数类型

整数类型有无符号和带符号两种。Go同时支持int和uint，这两种类型的长度相同，但具体长度取决于不同编译器的实现。
Go里面也有直接定义好位数的类型：rune，int8，int16，int32，int64，byte，uint8，uint16，uint32，uint64，其中rune是int32的别称，byte是uint8的别称。

```
int（有符号类型），32位系统占据4个字节（范围和int32一样），64位系统占据8个字节（范围和int64一样）     
int8    占据1字节   范围 -128 ~ 127
int16   占据2字节   范围 -2(15次方) ~ 2（15次方）-1
int32   占据4字节   范围 -2(31次方) ~ 2（31次方）-1
int64   占据8字节   范围 -2(63次方) ~ 2（63次方）-1
rune(有符号类型)，与int32一样，表示一个Unicode码

uint（无符号类型），32位系统占据4个字节（范围和uint32一样），64位系统占据8个字节（范围和uint64一样）     
uint8   占据1字节   范围 0 ~ 255
uint16  占据2字节   范围 0 ~ 2（16次方）-1
uint32  占据4字节   范围 0 ~ 2（32次方）-1
uint64  占据8字节   范围 0 ~ 2（64次方）-1
byte（无符号类型），与unit8等价，用于存储字符
```

注意：
- 上述类型的变量之间不允许互相赋值或操作，且int的长度是32 bit, 但int 与 int32并不可以互用。
- Go默认的整型类型是int
- 查看数据所占据的字节数方法：unsafe.Sizeof()


#### 2.2 浮点类型

浮点类型的分类
```
float32 单精度  占据4字节   范围 -3.403E38 ~ 3.403E38
float64 双精度  占据8字节   范围 -1.798E208 ~ 1.798E308
```

由上看出：
- 浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位  
- 浮点型的范围是固定的，不受操作系统限制
- .512 这样数可以识别为 0.512
- 科学计数法：5.1234e2 = 5.12 * 10 的 2 次方 5.12E-2 = 5.12/10 的 2 次方


精度损失：
```go
	var num1 float32 = -123.0000901
	var num2 float64 = -123.0000901 
	fmt.Println("num1=",num1)		//-123.00009
	fmt.Println("num2=",num2)		//-123.0000901
```

由上看出float64的精度要比float32要准确，一般使用float64

使用 == 号判断浮点数，是不可行的，替代方案如下：
```
func isEqual(f1,f2,p float64) bool {
   return math.Abs(f1-f2) < p           //p为用户自定义精度，如：0.00001
}
```

#### 2.3 复数

Go还支持复数。它的默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。
如下所示：
```
var t complex128
t = 2.1 + 3.14i
t1 = complex(2.1,3.14) //结果同上	
fmt.Println(real(t))   //实部：2.1
fmt.Println(imag(t))   //虚部：3.14
```

## 三 字符型

Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。  
字符类型可以以d%打印为整型。
```go
	var c1 byte = 'a'
	var c2 byte = '0'

	fmt.Println("c1=", c1)					//输出 97
	fmt.Println("c2=", c2)					//输出48
    fmt.Printf("c1=%c,c2=%c\n", c1, c2)	    //输出原值 a 0

    //var c3 byte = '北'
	//fmt.Printf("c3=%c", c3)					//溢出错误
```

说明：
- 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte
- 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存
- 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1)
- 字符可以和整型进行运算


